<task>
  <metadata>
    <phase>1</phase>
    <title>Foundation Infrastructure Setup</title>
    <timeline>Days 1-3</timeline>
    <token_budget>120K</token_budget>
    <agent_persona>backend + devops specialist</agent_persona>
    <complexity>high</complexity>
    <dependencies>none - starting fresh</dependencies>
  </metadata>

  <instructions>
    You are implementing Phase 1 of the OKR AI Agent project. Your role is a backend and DevOps specialist focused on creating solid technical foundations. This phase must be completed within 3 days and establish all core infrastructure needed for the conversational OKR creation system.

    CRITICAL SUCCESS CRITERIA:
    - Complete project structure with monorepo workspace setup
    - Functional SQLite database with full schema
    - Working Claude API integration with conversation context
    - Basic Express server with WebSocket support ready for frontend
    - Environment configuration and security basics implemented
  </instructions>

  <context>
    <project_overview>
      Building a local-first conversational AI agent that helps users create high-quality OKRs through intelligent questioning and coaching. The system prevents the common anti-pattern of turning project plans into OKRs by guiding users toward outcome-focused objectives and measurable key results.

      CORE PROBLEM: Humans often create waterfall plans disguised as OKRs (Objective: "deliver xyz project", KR: "project was delivered") rather than meaningful objectives that drive real outcomes.

      SOLUTION: Conversational AI that uses Claude Sonnet 4 to conduct structured interviews, detect anti-patterns, apply reframing techniques, and score OKR quality using established rubrics.
    </project_overview>

    <technical_constraints>
      - Local-first architecture (only Claude API calls external)
      - Single-process Node.js application for simplicity
      - SQLite + JSON files for data storage
      - Must run on developer's laptop with minimal setup
      - Target: <45 minute conversations, >80 quality scores
    </technical_constraints>

    <architecture_decisions>
      - Backend: Node.js 20+, TypeScript, Express, SQLite3, Socket.io
      - Frontend: React 18, TypeScript, Vite, shadcn/ui, Tailwind CSS
      - AI Integration: Claude Sonnet 4 API (Anthropic SDK)
      - State Management: Zustand (frontend), file-based sessions (backend)
      - Testing: Jest, React Testing Library, Playwright
    </architecture_decisions>
  </context>

  <phase_deliverables>
    <deliverable priority="critical">
      <title>Project Structure & Monorepo Setup</title>
      <description>Complete workspace configuration with server and client packages</description>
      <acceptance_criteria>
        - Root package.json with workspaces configured
        - server/ directory with TypeScript + Express setup
        - client/ directory with React + Vite setup
        - Proper TypeScript configurations for both workspaces
        - ESLint, Prettier, and development tools configured
        - Package scripts for development, build, and deployment
      </acceptance_criteria>
    </deliverable>

    <deliverable priority="critical">
      <title>SQLite Database Implementation</title>
      <description>Complete database schema with session and OKR storage</description>
      <schema_requirements>
        - sessions table: id, user_id, created_at, updated_at, phase, context, metadata
        - messages table: id, session_id, role, content, timestamp, metadata
        - okr_sets table: id, session_id, objective, objective_score, created_at, metadata
        - key_results table: id, okr_set_id, text, score, order_index, metadata
        - analytics_events table: id, event_type, session_id, data, timestamp
        - feedback_data table: id, session_id, satisfaction_rating, feedback_text, follow_up_data, timestamp
        - Proper indexes for performance
        - Foreign key constraints
      </schema_requirements>
      <acceptance_criteria>
        - Database initializes automatically on first run
        - All tables created with proper constraints
        - Sample data can be inserted and retrieved
        - Connection pooling implemented
        - Error handling for database operations
      </acceptance_criteria>
    </deliverable>

    <deliverable priority="critical">
      <title>Claude API Integration</title>
      <description>Anthropic Claude client with conversation management</description>
      <implementation_requirements>
        - Anthropic SDK integration with TypeScript
        - Conversation context management and persistence
        - Input sanitization for privacy protection
        - Rate limiting and error handling
        - Token usage tracking and budget management
        - Prompt template system for different conversation phases
      </implementation_requirements>
      <acceptance_criteria>
        - Can send messages to Claude and receive responses
        - Conversation context preserved across multiple turns
        - Rate limiting prevents API quota exhaustion
        - Sensitive data sanitized before API calls
        - Error handling with graceful degradation
        - Token usage monitored and logged
      </acceptance_criteria>
    </deliverable>

    <deliverable priority="critical">
      <title>Express Server Foundation</title>
      <description>HTTP server with WebSocket support and basic security</description>
      <api_endpoints>
        - POST /api/sessions - Create new conversation session
        - GET /api/sessions/:id - Retrieve session state
        - POST /api/sessions/:id/messages - Send message (will be replaced by WebSocket)
        - GET /api/sessions/:id/okrs - Get current OKR state
        - POST /api/export/:sessionId - Export OKRs in various formats
        - GET /api/health - Health check endpoint
      </api_endpoints>
      <websocket_events>
        - join-session: Connect to specific session
        - send-message: Send user message
        - receive-message: Get AI response
        - typing: Typing indicators
        - session-update: State changes
      </websocket_events>
      <acceptance_criteria>
        - Express server starts on port 3000
        - All REST endpoints respond correctly
        - WebSocket connections established and maintained
        - CORS configured for frontend development
        - Request validation and sanitization
        - Basic security headers implemented
        - Logging configured for debugging
      </acceptance_criteria>
    </deliverable>

    <deliverable priority="high">
      <title>Environment Configuration & Security</title>
      <description>Configuration management and basic security measures</description>
      <configuration_requirements>
        - .env file structure with all necessary variables
        - Configuration validation at startup
        - Different configs for development/production
        - Secrets management (API keys, encryption keys)
        - Error handling for missing configuration
      </configuration_requirements>
      <security_requirements>
        - Input validation with Joi schemas
        - SQL injection prevention
        - XSS protection for user content
        - Rate limiting on API endpoints
        - Secure headers (helmet.js)
        - Request size limits
      </security_requirements>
      <acceptance_criteria>
        - Application starts with proper configuration
        - Environment variables validated
        - Security middleware active
        - Rate limiting functional
        - Input validation prevents malicious content
        - Logs security events appropriately
      </acceptance_criteria>
    </deliverable>
  </phase_deliverables>

  <implementation_steps>
    <step order="1" duration="4 hours">
      <title>Initialize Project Structure</title>
      <actions>
        - Create root directory and initialize monorepo
        - Set up package.json with workspaces
        - Initialize server workspace with TypeScript + Express
        - Initialize client workspace with React + Vite
        - Configure shared TypeScript, ESLint, Prettier configs
        - Set up development scripts and tooling
      </actions>
      <validation>Run `npm install` and `npm run dev` successfully in both workspaces</validation>
    </step>

    <step order="2" duration="6 hours">
      <title>Implement Database Layer</title>
      <actions>
        - Design complete SQLite schema based on technical architecture
        - Implement database initialization and migration system
        - Create data access layer with TypeScript interfaces
        - Add connection pooling and error handling
        - Write basic CRUD operations for sessions and messages
        - Create database seeding for development
      </actions>
      <validation>Successfully create, read, update, delete session and message records</validation>
    </step>

    <step order="3" duration="8 hours">
      <title>Build Claude API Integration</title>
      <actions>
        - Install and configure Anthropic SDK
        - Implement ClaudeClient class with conversation context management
        - Add input sanitization and privacy protection
        - Create prompt template system for different conversation phases
        - Implement rate limiting and token budget tracking
        - Add comprehensive error handling and retry logic
      </actions>
      <validation>Send test conversation to Claude and receive contextually appropriate responses</validation>
    </step>

    <step order="4" duration="6 hours">
      <title>Create Express Server & WebSocket</title>
      <actions>
        - Set up Express server with TypeScript
        - Implement all required REST API endpoints
        - Add Socket.io for WebSocket communication
        - Configure CORS, security middleware (helmet), request validation
        - Implement session management and state persistence
        - Add health check and monitoring endpoints
      </actions>
      <validation>All API endpoints respond correctly, WebSocket connections work</validation>
    </step>

    <step order="5" duration="2 hours">
      <title>Environment & Security Setup</title>
      <actions>
        - Create comprehensive .env template
        - Implement configuration validation at startup
        - Add input validation with Joi schemas
        - Configure rate limiting and security headers
        - Set up logging system with appropriate levels
        - Test security measures against common attacks
      </actions>
      <validation>Application starts securely with proper configuration validation</validation>
    </step>
  </implementation_steps>

  <technical_specifications>
    <database_schema>
      <table name="sessions">
        <columns>
          id TEXT PRIMARY KEY
          user_id TEXT NOT NULL
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
          phase TEXT NOT NULL DEFAULT 'discovery'
          context JSON
          metadata JSON
        </columns>
        <indexes>
          CREATE INDEX idx_sessions_updated ON sessions(updated_at);
          CREATE INDEX idx_sessions_user ON sessions(user_id);
        </indexes>
      </table>
      <table name="messages">
        <columns>
          id INTEGER PRIMARY KEY AUTOINCREMENT
          session_id TEXT NOT NULL
          role TEXT NOT NULL CHECK (role IN ('user', 'assistant'))
          content TEXT NOT NULL
          timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
          metadata JSON
        </columns>
        <constraints>
          FOREIGN KEY (session_id) REFERENCES sessions(id)
        </constraints>
        <indexes>
          CREATE INDEX idx_messages_session ON messages(session_id, timestamp);
        </indexes>
      </table>
    </database_schema>

    <api_specifications>
      <endpoint method="POST" path="/api/sessions">
        <description>Create new conversation session</description>
        <request_body>
          {
            "userId": "string (optional)",
            "context": {
              "industry": "string (optional)",
              "function": "string (optional)",
              "timeframe": "quarterly|annual (optional)"
            }
          }
        </request_body>
        <response_success>
          {
            "sessionId": "uuid",
            "status": "created",
            "phase": "discovery"
          }
        </response_success>
      </endpoint>

      <endpoint method="GET" path="/api/sessions/:id">
        <description>Retrieve session state and conversation history</description>
        <response_success>
          {
            "sessionId": "uuid",
            "phase": "discovery|refinement|kr_discovery|validation",
            "messages": [
              {
                "id": "number",
                "role": "user|assistant",
                "content": "string",
                "timestamp": "ISO8601"
              }
            ],
            "context": {},
            "okrs": {}
          }
        </response_success>
      </endpoint>
    </api_specifications>

    <websocket_specifications>
      <event name="join-session">
        <payload>{ "sessionId": "uuid" }</payload>
        <description>Join specific conversation session</description>
      </event>
      <event name="send-message">
        <payload>{ "sessionId": "uuid", "content": "string" }</payload>
        <description>Send user message to AI agent</description>
      </event>
      <event name="receive-message">
        <payload>{ "sessionId": "uuid", "content": "string", "metadata": {} }</payload>
        <description>Receive AI response</description>
      </event>
    </websocket_specifications>
  </technical_specifications>

  <validation_gates>
    <gate name="database_functionality">
      <criteria>
        - All tables created without errors
        - Can insert and retrieve session data
        - Foreign key constraints working
        - Indexes improve query performance
      </criteria>
      <test_commands>
        - npm run db:migrate
        - npm run db:seed
        - npm run test:database
      </test_commands>
    </gate>

    <gate name="claude_integration">
      <criteria>
        - Can authenticate with Claude API
        - Receives appropriate responses to test prompts
        - Context maintained across conversation turns
        - Rate limiting prevents quota exhaustion
        - Sensitive data sanitized before API calls
      </criteria>
      <test_commands>
        - npm run test:claude-api
        - npm run test:conversation-flow
      </test_commands>
    </gate>

    <gate name="server_functionality">
      <criteria>
        - Server starts without errors
        - All API endpoints respond correctly
        - WebSocket connections established
        - Request validation working
        - Error handling prevents crashes
      </criteria>
      <test_commands>
        - npm run dev
        - curl http://localhost:3000/api/health
        - npm run test:api-endpoints
      </test_commands>
    </gate>

    <gate name="integration_test">
      <criteria>
        - Can create session via API
        - Can send message through WebSocket
        - Claude responds with contextually appropriate content
        - Session state persisted to database
        - No memory leaks or resource issues
      </criteria>
      <test_commands>
        - npm run test:integration
        - npm run test:performance
      </test_commands>
    </gate>
  </validation_gates>

  <constraints>
    <time_constraints>
      - Must complete within 72 hours (3 days)
      - Cannot proceed to Phase 2 without passing all validation gates
      - Each step should be completed within estimated duration
    </time_constraints>

    <technical_constraints>
      - SQLite only (no external database dependencies)
      - Local-first architecture maintained
      - All sensitive data stays on local machine
      - Must work with Node.js 18+ on Mac, Windows, Linux
    </technical_constraints>

    <quality_constraints>
      - All code must pass TypeScript strict mode
      - Test coverage >70% for critical paths
      - No SQL injection vulnerabilities
      - API response times <200ms for local operations
      - Memory usage <500MB during normal operation
    </quality_constraints>
  </constraints>

  <success_criteria>
    <primary_success>
      ✅ Backend server operational with all core infrastructure
      ✅ Database schema implemented and tested
      ✅ Claude API integration functional with conversation context
      ✅ WebSocket communication working for real-time updates
      ✅ Security measures implemented and validated
      ✅ Development environment ready for Phase 2 (Conversation Engine)
    </primary_success>

    <performance_targets>
      - Server startup time: <5 seconds
      - API response time: <200ms for database operations
      - Claude API integration: <3 seconds per request
      - Memory usage: <200MB baseline, <500MB under load
      - Database operations: <50ms for typical queries
    </performance_targets>

    <quality_targets>
      - Zero critical security vulnerabilities
      - All validation gates pass
      - TypeScript compilation with no errors
      - Basic test suite passes with >70% coverage
      - Code follows established patterns and conventions
    </quality_targets>
  </success_criteria>

  <handoff_to_phase_2>
    <deliverables_required>
      - Fully functional backend infrastructure
      - Complete database schema with sample data
      - Working Claude API client with context management
      - Express server with WebSocket support
      - Environment configuration and security measures
      - Basic test suite with integration tests
      - Documentation for setup and configuration
    </deliverables_required>

    <session_context_transfer>
      <current_state>
        Phase 1 completed successfully with all infrastructure operational.
        Backend ready to implement conversation logic and quality scoring.
      </current_state>

      <next_phase_priorities>
        1. Implement ConversationManager with multi-phase dialogue flow
        2. Build QualityScorer using established rubric
        3. Create AntiPatternDetector for common OKR mistakes
        4. Develop prompt engineering system for different conversation phases
      </next_phase_priorities>

      <technical_handoff>
        - Database connection pool ready for high-frequency operations
        - Claude API client configured with proper error handling and rate limiting
        - WebSocket infrastructure ready for real-time conversation updates
        - Session management system prepared for complex state tracking
      </technical_handoff>
    </session_context_transfer>
  </handoff_to_phase_2>

  <recovery_procedures>
    <if_behind_schedule>
      - Focus on critical deliverables only (database, Claude integration, basic server)
      - Defer advanced security features to later phases
      - Use simpler WebSocket implementation if full Socket.io proves complex
      - Implement minimal viable API first, expand endpoints in Phase 2
    </if_behind_schedule>

    <if_technical_blockers>
      - Claude API issues: Implement mock responses for development
      - Database problems: Fall back to JSON file storage temporarily
      - WebSocket complexity: Use HTTP polling as interim solution
      - TypeScript issues: Allow 'any' types temporarily with TODO comments
    </if_technical_blockers>

    <rollback_criteria>
      - If >80% over time budget after 2 days
      - If critical dependencies (Claude API, SQLite) prove unworkable
      - If security issues cannot be resolved within time constraints
      - If integration between components proves fundamentally incompatible
    </rollback_criteria>
  </recovery_procedures>
</task>